# (continue)

### Weaksets
* A WeakSet is just like a normal Set with a few key differences
  1. a WeakSet can only contain objects
  2. a WeakSet is not iterable which means it can't be looped over
  3. a WeakSet does not have a .clear() method
```js
let student1 = { name: 'James', age: 26, gender: 'male' };
let student2 = { name: 'Julia', age: 27, gender: 'female' };
let student3 = { name: 'Richard', age: 31, gender: 'male' };

const roster = new WeakSet([student1, student2, student3]);

console.log(roster);
// WeakSet {Object {name: 'Julia', age: 27, gender: 'female'},
//          Object {name: 'Richard', age: 31, gender: 'male'},
//          Object {name: 'James', age: 26, gender: 'male'}}

roster.add('Amanda'); // Uncaught TypeError: Invalid value used in weak set(…)

// WHY use WeakSet? => you can freed up memory when garbage collection runs
// => doesn't prevent gabage collection, this makes WeakSets useful in
// situations where you want an efficient, lightweight solution for creating groups of objects
student3 = null;
console.log(roster); // WeakSet {Object {name: 'Julia', age: 27, gender: 'female'}, Object {name: 'James', age: 26, gender: 'male'}}
```

### Quiz: Working with weakSets

### Maps
* Maps are unique because they're collection of key-value pairs
* Sets are similar to Arrays, and Maps are similar to Objects

### Creating & Modifying Maps
* you have to add values by using `.set(key, values)` method (returns Map object itself if success)
* to remove key-value pairs, use `.delete()` method (returns boolean)
* to remove all, use `.clear()` method
  ```js
  const employees = new Map();
  console.log(employees); // Map {}

  employees.set('james.parkes@udacity.com', {
      firstName: 'James',
      lastName: 'Parkes',
      role: 'Content Developer'
  });
  employees.set('julia@udacity.com', {
      firstName: 'Julia',
      lastName: 'Van Cleve',
      role: 'Content Developer'
  });
  employees.set('richard@udacity.com', {
      firstName: 'Richard',
      lastName: 'Kalehoff',
      role: 'Content Developer'
  });

  console.log(employees); // Map {'james.parkes@udacity.com' => Object {...}, 'julia@udacity.com' => Object {...}, 'richard@udacity.com' => Object {...}}

  employees.delete('julia@udacity.com');
  employees.delete('richard@udacity.com');
  console.log(employees); // Map {'james.parkes@udacity.com' => Object {firstName: 'James', lastName: 'Parkes', role: 'Course Developer'}}

  employees.clear()
  console.log(employees); // Map {}
  // If you .set() a duplicate key to a Map, there's no error, but the key-value pair will overwrite
  // if you try to .delete() a non-existance key-value, there's no error, but the Map will remain unchanged.
  ```

### Working with Maps
* use `.has(key)` to check if a key-value pair exist
* use `.get()` method to retrieve values
  ```js
  const members = new Map();

  members.set('Evelyn', 75.68);
  members.set('Liam', 20.16);
  members.set('Sophia', 0);
  members.set('Marcus', 10.25);

  console.log(members.has('Xavier')); // false
  console.log(members.has('Marcus')); // true

  console.log(members.get('Evelyn')); // 75.68
  ```

### Looping Through Maps
* Using the MapIterator
  ```js
  let iteratorObjForKeys = members.keys();
  iteratorObjForKeys.next(); // Object {value: 'Evelyn', done: false}
  iteratorObjForKeys.next(); // Object {value: 'Liam', done: false}
  iteratorObjForKeys.next(); // Object {value: 'Sophia', done: false}

  // use the .values() method to access the Map’s values, and then repeat the same process.
  let iteratorObjForValues = members.values();
  iteratorObjForValues.next(); //  Object {value: 75.68, done: false}
  ```
* using for...of loop
  ```js
  for (const member of members) { console.log(member); }
  /* result: (note, you don't get key nor value, you got an array w/ 1st ele as key and 2nd as value)
    ['Evelyn', 75.68]
    ['Liam', 20.16]
    ['Sophia', 0]
    ['Marcus', 10.25]
  */

  // leverage the use of array destructuring
  for (const [memberKey, memberValue] of members) { console.log(memberKey, memberValue); }
  /* result: (now you can access the key or value)
    Evelyn 75.68
    Liam 20.16
    Sophia 0
    Marcus 10.25
  */
  ```
* using .forEach() method
  ```js
  members.forEach((key, value) => console.log(key, value));
  /* result:
    'Evelyn' 75.68
    'Liam' 20.16
    'Sophia' 0
    'Marcus' 10.25
  */
  ```

### WeakMaps
* WeakMap is just like normal Map with a few key differences:
  1. a WeakMap can only contain objects as keys,
  2. a WeakMap is not iterable which means it can’t be looped and
  3. a WeakMap does not have a .clear() method.
* Example:
  ```js
  const book1 = { title: 'Pride and Prejudice', author: 'Jane Austen' };
  const book2 = { title: 'The Catcher in the Rye', author: 'J.D. Salinger' };
  const book3 = { title: 'Gulliver’s Travels', author: 'Jonathan Swift' };

  const library = new WeakMap();
  library.set(book1, true);
  library.set(book2, false);
  library.set(book3, true);

  console.log(library);
  // WeakMap {Object {title: 'Pride and Prejudice', author: 'Jane Austen'} => true,
  //          Object {title: 'The Catcher in the Rye', author: 'J.D. Salinger'} => false,
  //          Object {title: 'Gulliver’s Travels', author: 'Jonathan Swift'} => true}

  // …but if you try to add something other than an object as a key, you’ll get an error!
  // library.set('The Grapes of Wrath', false); // Uncaught TypeError: Invalid value used as weak map key(…)

  // similar to WeakSets, WeakMaps leverage garbage collection for easier use and maintainability
  // If you set an object to null, then you’re essentially deleting the object.
  // And when collector runs, the memory that was occupied will be freed up to be used later

  book1 = null;
  console.log(library);
  // WeakMap {Object {title: 'The Catcher in the Rye', author: 'J.D. Salinger'} => false,
  //          Object {title: 'Gulliver’s Travels', author: 'Jonathan Swift'} => true}

  // WeakMaps is useful where u want an efficient, lightweight solution for creating groupings of objects with metadata
  ```

### Promises Intro
* using JS promise is the new way to handle asynchoronous requrest
* "do this thing now, and then notify me when it's done so i can pick up where i left off"

### Promises
* A JS Promise is created witht he new Promise constructor functin - `new Promise()`
* the argument of the constructor fn must be the code that will be run asynchronously
* Indicate a successful request (`resolve`) or a failed request (`reject`) (these are methods)
  ```js
  new Promise(function (resolve, reject) {
    window.setTimeout(function createSundae(flavor = 'chocolate') {
      const sundae = {};
      // request ice cream
      // get cone
      // warm up ice cream scoop
      // scoop generous portion into cone!
      if ( /* iceCreamConeIsEmpty(flavor) */ ) {
        reject(`Sorry, we're out of that flavor T__T`);
      }
      resolve(sundae);
      // when the promise is 'fulfilled', either resolved or rejected, data is sent back w/ response
    }, Math.random() * 2000);
  });
  ```
* Promise will immediately return an object, which has a `.then()` method on it
  * `.then()` method takes 2 fns:
    1. the fn to run if the request completed successfully
    2. the fn to run if the request failed to complete
  ```js
  const myPromiseObj = new Promise(function (resolve, reject) {
      // sundae creation code
  });
  mySundae.then(function(sundae) {
      console.log(`Time to eat my delicious ${sundae}`);
  }, function(msg) {
      console.log(msg);
      // self.goCry(); // not a real method
  });
  ```

### Proxies Intro
* proxy is something that represents someone else
* A proxy in JS will let one object stand in for another object to handle all the interactions
  * like a personal secretary who can do things on-behalf-of the boss
  * JS proxy can handle request directly
  * JS proxy can pass data back and forth tot he target object

### Proxies
* To create a proxy object, we use the Proxy constructor - `new Proxy();`.
* The proxy constructor takes two items:
  1. the object that it will be the proxy for
  2. the handler object: an object containing the list of methods it will handle for the proxied object
* A Pass Through Proxy and the `get` trap (called a trap b/c it's being used in a Proxy)
  ```js
  // The simplest way to create a proxy is to provide an object and then an empty handler object.
  const richard = {status: 'looking for work'};
  const agent = new Proxy(richard, {});
  agent.status; // 'looking for work'

  // The `get` trap is used to "intercept" calls to properties:
  const handler = {
    get(target, propName) {
      console.log(target); // {status: 'looking for work'}
      console.log(propName); // status
      return target[propName];
      // alternatively, we could use proxy to provide direct feedback
      // return 'Someone sent him a lead recently!';
      // with this 'return', Proxy doesn't even check target object, it just responds directly to the calling code
    }
  };
  const agent2 = new Proxy(richard, handler);
  agent2.status;
  // when 'agent2.status' is run, b/c the 'get' trap exist, it "intercepts" the status call and run the 'get' trap fn
  // (1) logs out the richard object
  // (2) logs out the name of the property being accessed (`status`)
  // (3) return the text in richard.status (`looking for work`)
  // If a trap is used, u need to make sure you provide all the functionality for that specific trap

  // The `set` trap is used for intercepting code that will 'change a property'
  const handler2 = {
    set(target, propName, value) {
      if (propName === 'payRate') { // if the pay is being set, take 15% as commission
        value = value * 0.85;
      }
      target[propName] = value;
      }
  };
  const agent3 = new Proxy(richard, handler);
  agent3.payRate = 1000; // set the actor's pay to $1,000
  agent3.payRate; // $850 the actor's actual pay
  ```
* Other traps:
  * the `get` trap - lets the proxy handle calls to property access
  * the `set` trap - lets the proxy handle setting the property to a new value
  * the `apply` trap - lets the proxy handle being invoked (the object being proxied is a function)
  * the `has` trap - lets the proxy handle the using in operator
  * the `deleteProperty` trap - lets the proxy handle if a property is deleted
  * the `ownKeys` trap - lets the proxy handle when all keys are requested
  * the `construct` trap - lets the proxy handle when the proxy is used with the new keyword as a constructor
  * the `defineProperty` trap - lets the proxy handle when defineProperty is used to create a new property on the object
  * the `getOwnPropertyDescriptor` trap - lets the proxy handle getting the property's descriptors
  * the `preventExtenions` trap - lets the proxy handle calls to Object.preventExtensions() on the proxy object
  * the `isExtensible` trap - lets the proxy handle calls to Object.isExtensible on the proxy object
  * the `getPrototypeOf` trap - lets the proxy handle calls to Object.getPrototypeOf on the proxy object
  * the `setPrototypeOf` trap - lets the proxy handle calls to Object.setPrototypeOf on the proxy object

### Proxies vs. ES5 Getter/Setter
* with getter and setter method in ES5, you need to know *before hand* the properties that are going to be get/set
* with proxies, you do not need to initialize the object with getters/setters for each property when the object is initialized.
  ```js
  var obj = {
    _age: 5,
    _height: 4,
    get age() {
      console.log(`getting the "age" property`);
      console.log(this._age);
    },
    get height() {
      console.log(`getting the "height" property`);
      console.log(this._height);
    }
  };

  obj.age; // logs 'getting the "age" property' & 5
  obj.height; // logs 'getting the "height" property' & 4

  // But look what happens when we now add a new property to the object:
  obj.weight = 120; // set a new property on the object
  console.log(obj.weight); // 120, just log the number without any message

  // With ES6 Proxies, we do not need to know the properties beforehand:
  const proxyObj = new Proxy({age: 5, height: 4}, {
    get(targetObj, property) {
      console.log(`getting the ${property} property`);
      console.log(targetObj[property]);
    }
  });

  proxyObj.age; // logs 'getting the age property' & 5
  proxyObj.height; // logs 'getting the height property' & 4

  // but look what happens when we add a new property:
  proxyObj.weight = 120; // set a new property on the object
  proxyObj.weight; // logs 'getting the weight property' & 120
  ```

### Proxies Recap
* a trap is a fn that will intercepts call to the properties let you run code
* if a trap is not defined, the default behabvior is sent to the target object
* proxies are a powerful new way to create and manage the interactions between objects

### Generators
* **run-to-completion**: JS engine starts at top and runs to the bottom
* generator functions: pausable functions (use `*` to indicate, put anywhere between the function keyword and the function's name)
  * `function* name(0 { /* ... */ }`
  * `function * name(0 { /* ... */ }`
  * `function *name(0 { /* ... */ }`
* Example:
  ```js
  function* getEmployee() {
    console.log('the function has started');
    const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];
    for (const name of names) {
        console.log( name );
    }
    console.log('the function has ended');
  }
  getEmployee();
  // this is the response in Chrome:
  // getEmployee {[[GeneratorStatus]]: "suspended", [[GeneratorReceiver]]: Window}

  console.log(getEmployee()); // Object [Generator] {}
  ```

### Generators & Iterators


### Sending Data Into/out of a Gen...


### Lesson 3 Summary
